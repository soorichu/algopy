0. 탐색의 개념
여러 원소로 구성된 데이터에서 원하는 값을 가진 원소를 찾는 것
내부탐색 vs 외부탐색
탐색연산 + 초기화(정렬), 삽입, 삭제 등의 연산도 함께 고려해야 함.
(1) 순차탐색
(2) 이진탐색
(3) 탐색트리 - 이진탐색트리, 흑적트리, B-트리
(4) 해싱 - 해시함수, 충돌해결방법


1. 순차 탐색 
리스트 형태로 주어진 원소들을 처음부터 하나씩 차례로 살펴보며 원하는 값을 가진 원소를 찾는 방법
모든 리스트에 적용 가능 - 원소가 무순서로 연속해서 저장된 '비정렬 데이터 탐색'에 적합.
초기화가 필요 없음.
데이터가 큰 경우 부적합. 성능이 좋지 않음
순차탐색 = O(n)
순차탐색 삽입 = O(1)
순차탐색 삭제 = O(n)
연결리스트로 구현할 수 있음.(연결리스트는 순차탐색만을 제공함)


2. 이진 탐색
정렬된 리스트형태로 주어진 원소들을 분할정복 방법(2장, 3강)으로 절반씩 줄여 가면서 원하는 값을 가진 원소를 찾는 방법
1. 입력이 정렬된 리스트에 대해서만 적용이 가능하다.
2. 데이터의 사빕/삭제 연산을 수행하면 데이터의 이동이 발생
데이터 삽입/삭제 후에는 데이터를 정렬 상태로 유지하기 위해 평균적으로 n/2개의 데이터를 
이동해야 하기 때문에 삽입과 삭제가 빈번한 응용에서의 탐색으로 적합하지 않음. 
이진탐색 = O(logn)
초기화 = O(nlogn)
이진탐색 삽입 = 탐색O(logn) + 뒤로밀기O(n) = O(n)
이진탐색 삭제 = 탐색O(logn) + 앞으로땡기기O(n) = O(n)
삽입 삭제의 경우 정렬된 리스트에서만 적용이 가능. 초기화가 필요함
삽입과 삭제가 빈번하게 발생하는 경우는 이진탐색이 부적합
연결리스트 구조에서는 이진탐색 자체가 불가능!


3. 이진 탐색 트리
이진 트리 - 각 노드의 왼쪽(오른쪽) 서브트리에 있는 모든 키값은 그 노드의 키값보다 작다(크다). 
노드의 구조(C언어)
struct node{
	struct node *Left;
	int key;
	struct node *Right;
};
시간복잡도는 키값을 비교하는 횟수에 비례 - 이진 트리의 높이가 h라면 O(h)
모든 노드의 차수가 2인 경우 = O(logn)
경사이진트리(모든 노드의 차수가 1인 경우) = O(n)
삽입 삭제 시 기존 노드의 이동이 거의 발생하지 않음
원소의 삽입 삭제에 따라 경사트리형태가 될 수 있음
최악의 수행시간 O(n)을 가진 - 경사트리가 되지 않도록 유지해서 O(logn)을 보장
-> 균형탐색트리(흑적트리, B-트리)


4. 흑적트리
이진탐색트리, 균형탐색트리
2-3-4트리를 이진탐색트리로 표현한 것이 흑적트리
(1) 모든 노드는 흑색이거나 적색
(2) 루트와 리프는 흑색 - 모든 리프노드는 Null 노드
(3) 적색 노드의 부모 노드는 항상 흑색 - 적색 노드가 연달아 나타날 수 없음
(4) 임의의 노드로부터 리프노드까지 경로 상에는 동일한 개수의 흑색 노드가 존재
노드 = | left | color | key | right | parent | sibling |
이진탐색트리에서의 탐색방법과 동일
적색노드가 연달아 나타나는 경우 적용하는 규칙
(1) 삼촌노드가 적색인 경우 - 부모노드, 삼촌노드, 조부모노드의 색깔을 모두 변경
(2) 삼촌노드가 흑색이고, 현재노드의 키값이 조/부모노드의 키값의 사이인 경우 - 현재노드와 부모노드 회전
(3) 삼촌노드가 흑색이고, 현재노드의 키값보다 조/부모노드의 키값이 큰(작은) 경우 - 부모노드와 조부모노드를 회전시키고 색깔 변경
탐색, 삽입, 삭제 = O(logn)


5. B-트리
균형탐색트리
(1) 루트노드는 1 ~ (2t-1)개의 오름차순으로 정렬된 키를 가짐
(2) 루트노드가 아닌 모든 노드는 (t-1) ~ (2t-1)개의 오름차순으로 정렬된 키를 가짐
(3) 내부노드는 자신의 키의 개수보다 하나 많은 자식노드를 가짐
(4) 한 노드의 한 키의 왼쪽 서브트리에 있는 모든 키값은 그 키값보다 작고, 오른쪽 서브트리에 있는 모든 키값은 그 키값보다 크다.
(5) 모든 리프노드의 레벨이 동일
노드분할 - 삽입을 위한 탐색과정에서 (2t-1)개의 키를 갖는 노드를 만나면, 이 노드의 가운데 키를 부모노드로 올리고 나머지를 두 개의 노드로 쪼갠다.
트리의 높이 h-> O(th)
 - 각 노드에서는 (t-1) ~ (2t-1)개의 키와 t ~ 2t개의 자식 노드를 가짐
 - 모든 리프노드의 레벨은 동일하다.
트리의 높이 h -> O(log(t, n))
각 노드에서의 키 관리에 흑적 트리를 이용하면 O(t) -> O(log(t))
따라서 O(log(t)*log(t, n)) = O(logn) 이것만 기억!!(최악에서도!)
t=2인 경우가 2-3-4트리

6. 해싱
탐색 키값을 기반으로 데이터 저장 위치를 직접 계산
- 상수 시간 O(1) 내에 데이터를 탐색, 삽입, 삭제 가능
해시함수 : {1..n} ----> [0..M-1]  (n>>M) 반드시 충돌이 생길 수 밖에 없음.
충돌이 적게 생기게, 충돌이 생겼을 때 해결 방법이 중요
해싱이 적합한 형태의 응용문제 - 특정 키값을 갖는 데이터를 찾는 문제
해싱함수 종류 - 제산잔여법, 비닝, 중간제곱법, 문자열을 위한 함수 등
바람직한 해시함수는 - 계산용의, 각 키값을 균등하게 사상시킬 수 있는 함수
(1) 제산잔여법
h(K) = K mod M
M=2^r이면 h(K)는 하위 r비트의 값이 됨. 키값의 전체비트를 주소 계산에 활용하지 못함. => 2의 멱수와 상당한 차이가 있는 소수로 M을 선택해야 한다.
(2)비닝
h(K)=K/M
(3) 중간제곱법
h(K) = (K^2/2^m) mod 2^r  m : 키값의 자릿수  r : M의 자릿수
(4) 문자열 해시 함수
aaaabbbb = a*4+b*4
aaaabbbb = a*자릿값들 + b*자릿값들
*충돌해결방법
(1) 개방해싱(연쇄법) 
- 충돌된 데이터를 테이블 밖의 별도의 장소에 저장 관리(연결리스트로)
- 해시테이블과 연결리스트가 주기억장치 내에서 유지될 때 적합
(2) 폐쇄 해싱(개방 주소법)
- 테이블 내의 다른 슬롯에 충돌된 데이터를 저장 관리
	ㄱ. 버킷해싱 : M-F개의 해시와 F개의 오버플로우 버킷(공통사용). 디스크에 저장된 해시 테이블을 구현하는데 적합
	ㄴ. 선형탐사 : p(K, i) = (h(K)+i) mod M 간단하지만 최악의 방법. 1차 클러스터링(데이터들이 연속된 위치를 점유하여 클러스터를 형성하고 이것이 점점 커지는 현상)
	ㄷ. 이차탐사 : p(K, i) = (h(K) + c1xi^2 + c2xi + c3) mod M 모든 슬롯이 탐사순서에 사용되지 않음. 2차 클러스터링(서로 다른 두 키의 홈 위치가 동일하면 전체 탐사순서가 동일)
	ㄹ. 이중해싱 : p(K, i) = (h1(K) + i*h2(K)) mod M 서로 다른 두 키의 홈 위치가 동일해도 서로 다른 탐사 순서를 가짐. 좋은 이중해싱을 구현혀라면 탐사순서의 모든 상수가 테이블 크기 M과 서로소가 되어야 함.
*삭제 연산
- 데이터의 삭제가 차후의 탐색을 방해하지 않아야 한다.
- 삭제로 인해 해시 테이블의 위치에서 사용할 수 없는 곳을 만들지 않아야 한다.
-> 비석(tombstone) - 삭제된 데이터의 위치에 비석이라는 특별한 표시를 함. 탐색시에는 비석을 무시하고, 삽입할 때는 비석이 표시된 부분에 새 데이터를 삽입
- 그러나 비석이 많아 질수록 평균 탐색 거리가 증가하는 문제. 

